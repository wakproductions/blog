<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2017-02-28T01:30:00-05:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>How to Install Ruby on a Production System with Ansible</title>
    <link rel="alternate" href="http://blog.url.com/2017/02/28/install-ruby-on-a-production-system.html"/>
    <id>http://blog.url.com/2017/02/28/install-ruby-on-a-production-system.html</id>
    <published>2017-02-28T01:30:00-05:00</published>
    <updated>2017-02-28T09:58:22-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;I recently had to set up a production server to run Ruby. Surprisingly there are many opinions on how to do it. Some
people use RVM or RBenv, but I&amp;#39;ve been told by other people who have tried that that in a production system the system
hacks those package managers use to get the magic to work can have unintended side effects. For example, RVM&amp;#39;s override
of the shell causes problems when trying to use Ruby with UNIX cron jobs.&lt;/p&gt;

&lt;p&gt;Doing the build-from-scratch install of system Ruby seems to be the best option for setting up a production server.
&lt;a href="http://robmclarty.com/blog/how-to-setup-a-production-server-for-rails-4"&gt;I found this useful blog article&lt;/a&gt;, which I&amp;#39;m reposting an excerpt here in case it ever disappears from the Internet. The setup
process should be largely the same for any other versions of Ruby.&lt;/p&gt;

&lt;h3&gt;Excerpt from robmclarty.com&lt;/h3&gt;

&lt;p&gt;I wanted to setup the bleeding edge on this server, so I went with a source code install process for Ruby rather than a pre-existing package. I installed Ruby 2.0 and Rails 4.beta. What I usually do to keep track of my source-code-installed components is create a src directory in my user&amp;#39;s home folder inside which I store all my source code folders for compilation, installation, and later, any uninstallation I might need to do.&lt;/p&gt;

&lt;p&gt;But before that, I needed to install a few more dependencies so my server environment was ready for it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential libyaml-dev libsqlite3-0 libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion
Next, inside /home/bill/src and got the latest Ruby, decompressed it, configured, compiled, and installed.

wget ftp://ftp.ruby-lang.org/pub/ruby/2.0/ruby-2.0.0-p0.tar.gz
tar xzvf ruby-2.0.0-p0.tar.gz
cd ruby-2.0.0-p0
./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I made a symbolic link from /usr/local/bin/ruby to /usr/bin/ruby because some programs look for it there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ln -s /usr/local/bin/ruby /usr/bin/ruby
The newer Rubies come with rubygems so you don&amp;#39;t need to worry about installing that separately anymore. But before installing any new gems (like Rails) it&amp;#39;s always a good idea to make sure it&amp;#39;s up to date.

sudo gem update --system
Finally, now that there was a convenient beta1 branch for the Rails gem, all I needed to do was install the latest Rails was the following.

sudo gem install rails --version 4.0.0.beta1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I encountered some weird issues with rdoc and ri where I had to answer &amp;quot;yes&amp;quot; to overwrite the existing versions. I just went with it since this is a dedicated server and I care more about the app working than some documentation that isn&amp;#39;t necessary for me in production. I&amp;#39;m sure this will be fixed in the final release.&lt;/p&gt;

&lt;p&gt;Update: @kaspergrubbe gave me a great little tweak so you don&amp;#39;t need to specify --no-ri --no-rdoc every time you install a gem in production: just add gem: --no-rdoc --no-ri to ~/.gemrc (create that file if it doesn&amp;#39;t already exist) and don&amp;#39;t worry about ri or rdoc again in production.&lt;/p&gt;

&lt;h1&gt;Throw in some Ansible&lt;/h1&gt;

&lt;p&gt;I automated these steps using Ansible to install Ruby 2.3.3 on my system. &lt;a href="https://github.com/wakproductions/ansible-examples/blob/master/roles/web/tasks/install_ruby233.yml"&gt;Here&amp;#39;s the playbook.&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Pretty Print a Really Big Hash in Ruby</title>
    <link rel="alternate" href="http://blog.url.com/2017/02/16/pretty-print-a-really-big-hash-to-string-in-ruby.html"/>
    <id>http://blog.url.com/2017/02/16/pretty-print-a-really-big-hash-to-string-in-ruby.html</id>
    <published>2017-02-16T01:30:00-05:00</published>
    <updated>2017-02-16T13:00:57-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Problem: Copy and paste a really big Ruby object so that it&amp;#39;s human readable&lt;/h2&gt;

&lt;p&gt;Today I was building a fixture in one of my RSpec tests which consisted of a really big hash. It looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;really_big_hash =     {:Profile=&amp;gt;
                         {:CharterNumber=&amp;gt;&amp;quot;68448&amp;quot;,
                          :CreditUnionId=&amp;gt;&amp;quot;14241&amp;quot;,
                          :CreditUnionName=&amp;gt;&amp;quot;CITIZENS EQUITY FIRST&amp;quot;,
                          :CycleDate=&amp;gt;&amp;quot;12/31/2015&amp;quot;,
                          :CreditUnionTypeID=&amp;gt;&amp;quot;FISCU&amp;quot;,
                          :Region=&amp;gt;&amp;quot;4&amp;quot;,
                          :CreditUnionStatus=&amp;gt;&amp;quot;Active&amp;quot;,
                          :DateChartered=&amp;gt;&amp;quot;2000&amp;quot;,
                          :DateInsured=&amp;gt;&amp;quot;1/2/1975&amp;quot;,
                          :CharterStateCode=&amp;gt;&amp;quot;Illinois&amp;quot;,
                          :TOM_CODE=&amp;gt;&amp;quot;99&amp;quot;,
                          :State=&amp;gt;&amp;quot;IL&amp;quot;,
                          :Acct_896=&amp;gt;&amp;quot;1&amp;quot;,
                          :PeerGroup=&amp;gt;&amp;quot;6 - $500,000,000 and greater&amp;quot;,
                          :Assets=&amp;gt;&amp;quot;5174819725&amp;quot;,
                          :NumberOfMembers=&amp;gt;&amp;quot;312929&amp;quot;,
                          :IsLowIncome=&amp;gt;&amp;quot;No&amp;quot;,
                          :CertificationDate=&amp;gt;&amp;quot;1/22/2016 10:46:28 AM&amp;quot;,
                          :HasWebSite=&amp;gt;&amp;quot;Yes&amp;quot;,
                           ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I tried to copy this fixture into my test file, I initially did this in console:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;clipboard&amp;#39; # use the Clipboard gem
Clipboard.copy(really_big_hash)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem was that when I pasted the text it all ended up on one line like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;{:Profile=&amp;gt;{:CharterNumber=&amp;gt;&amp;quot;68448&amp;quot;, :CreditUnionId=&amp;gt;&amp;quot;14241&amp;quot;, :CreditUnionName=&amp;gt;&amp;quot;CITIZENS EQUITY FIRST&amp;quot;, :CycleDate=&amp;gt;...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Solution: Ruby&amp;#39;s &amp;#39;pp&amp;#39; module&lt;/h2&gt;

&lt;p&gt;I discovered that the Ruby &amp;#39;pp&amp;#39; module could be used to format a Hash as a multiline output and I could capture the
output. Here&amp;#39;s what I did:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;require &amp;#39;pp&amp;#39;
cap = StringIO.new
$stdout = cap
pp(r)
$stdout = STDOUT

Clipboard.copy(cap.string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I was then able to paste my Hash as a more human-readable multi-line string. Note that because &lt;code&gt;pp&lt;/code&gt; prints to screen
by default, I had to reroute &lt;code&gt;$stdout&lt;/code&gt; temporarily to capture the output via a &lt;code&gt;StringIO&lt;/code&gt; object.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Better Bulk Inserts in Rails</title>
    <link rel="alternate" href="http://blog.url.com/2017/01/14/bulk-insert-in-rails-and-mysql.html"/>
    <id>http://blog.url.com/2017/01/14/bulk-insert-in-rails-and-mysql.html</id>
    <published>2017-01-14T01:30:00-05:00</published>
    <updated>2017-01-14T23:46:42-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;One of the limitations of Rails is that it doesn&amp;#39;t do a true bulk insert. For example, let&amp;#39;s say you have a &lt;code&gt;MenuItem&lt;/code&gt;
model and pass it an array of objects to create like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;items_to_create = [
  {
    name: &amp;#39;Sandwich&amp;#39;,
    description: &amp;#39;Chips included&amp;#39;,
    price: 10.00,
  },
  {
    name: &amp;#39;Soup&amp;#39;,
    description: &amp;#39;Cream of mushroom&amp;#39;,
    price: 3.00    
  },
  {
    name: &amp;#39;Salmon&amp;#39;,
    description: &amp;#39;Pan seared&amp;#39;,
    price: 17.00
  },
]

MenuItem.create!(items_to_create)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you call &lt;code&gt;MenuItem.create!&lt;/code&gt;, ActiveRecord will actually perform 3 separate INSERT queries on the database rather 
than one bulk insert query. It will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;INSERT INTO models (...) VALUES (...);
INSERT INTO models (...) VALUES (...);
INSERT INTO models (...) VALUES (...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem with this approach is that it is inefficient - DB engines are much faster at peforming INSERT when fed the 
data all at once. I&amp;#39;m working on a project that requires a huge manipulation of data and thus many DB queries. To make 
it run faster I&amp;#39;ve tried to minimize the number of individual queries. One way that I was able to speed this up is to 
build my own native bulk insert routine for ActiveRecord that works with MySQL. Here is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;# app/models/concerns/has_bulk_insert.rb

module HasBulkInsert
  extend ActiveSupport::Concern

  included do
  end

  class_methods do
    BI_IGNORE_COLUMNS=%w(id)

    def bulk_insert(values_array)
      return if values_array.empty?
      ActiveRecord::Base.connection.execute bi_sql(values_array)
    end

    protected
    def bi_column_definitions
      self
        .columns_hash
        .map {|col,props| BI_IGNORE_COLUMNS.include?(col) ? nil : {col=&amp;gt;props.type} }
        .compact
        .reduce({}, :merge)
    end

    def bi_escaped_column_names
      bi_column_definitions.reduce([]) { |m,(k,v)| m &amp;lt;&amp;lt; &amp;quot;`#{k}`&amp;quot; }.join(&amp;#39;,&amp;#39;)
    end

    def bi_sql(values_array)
      &amp;lt;&amp;lt;SQL
INSERT INTO #{self.table_name} (#{bi_escaped_column_names}) VALUES
#{bi_convert_values_array(values_array)};
SQL
    end

    def bi_convert_values_array(values_array)
      values_array.map do |values_hash|
        line_values = bi_column_definitions.reduce([]) do |line, (col,definition)|
          vh = values_hash.stringify_keys

          next line &amp;lt;&amp;lt; &amp;#39;NULL&amp;#39; if vh[col].nil? &amp;amp;&amp;amp; !is_timestamp_column?(col)

          case definition
            when :string, :text
              if is_enum_column?(col)
                line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{enum_value(col, vh[col])}&amp;#39;&amp;quot;
              else
                line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{vh[col].gsub(&amp;quot;&amp;#39;&amp;quot;, &amp;quot;&amp;#39;&amp;#39;&amp;quot;)}&amp;#39;&amp;quot;
              end
            when :date
              line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{vh[col].strftime(&amp;#39;%Y-%m-%d&amp;#39;)}&amp;#39;&amp;quot;
            when :datetime
              if is_timestamp_column?(col)
                line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{Time.now.strftime(&amp;#39;%Y-%m-%d %H:%M:%S&amp;#39;)}&amp;#39;&amp;quot;
              else
                line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{vh[col].strftime(&amp;#39;%Y-%m-%d&amp;#39;)}&amp;#39;&amp;quot;
              end
            when :integer
              if vh[col].is_a? Integer
                line &amp;lt;&amp;lt; vh[col].to_s
              elsif vh[col].is_a?(String) &amp;amp;&amp;amp; is_enum_column?(col)
                line &amp;lt;&amp;lt; &amp;quot;&amp;#39;#{enum_value(col, vh[col])}&amp;#39;&amp;quot;
              else
                raise &amp;quot;Unable to interpret data for column #{col}\n#{vh}&amp;quot;
              end
            when :decimal, :boolean
              line &amp;lt;&amp;lt; vh[col].to_s
            else
              raise &amp;quot;Unknown data column type: #{definition}&amp;quot;
          end
        end
        .join(&amp;#39;,&amp;#39;)

        &amp;quot;(#{line_values})&amp;quot;
      end
      .join(&amp;quot;,\n&amp;quot;)
    end

    def enum_value(column_name, enumeration_value)
      self.send(column_name.pluralize)[enumeration_value]
    end

    def is_enum_column?(column_name)
      self.defined_enums.include?(column_name)
    end

    def is_timestamp_column?(column_name)
      %w(created_at updated_at).include?(column_name)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this, all you have to do is include the module in your model like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;class MenuItem &amp;lt; ApplicationRecord
  include HasBulkInsert
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can call the method:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;MenuItem.bulk_insert(items_to_create)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SQL query used by ActiveRecord will be consolidated to look more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;INSERT INTO models (...) VALUES
  (...),
  (...),
  (...),
  (...),
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One limitation of my code module at this point is that it does not support serialized fields, but it is excellent for
basic tables and speeds things up tremendously - by about 50% in my local bench tests!&lt;/p&gt;

&lt;h3&gt;Related Links&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1793169/which-is-faster-multiple-single-inserts-or-one-multiple-row-insert"&gt;StackOverflow: Which is faster: single inserts or one multiple row insert?&lt;/a&gt; &lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>AWS S3 Code Examples in Ruby (aws-sdk 2.0)</title>
    <link rel="alternate" href="http://blog.url.com/2017/01/12/s3-code-examples.html"/>
    <id>http://blog.url.com/2017/01/12/s3-code-examples.html</id>
    <published>2017-01-12T01:30:00-05:00</published>
    <updated>2017-01-14T23:46:42-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h3&gt;Logging in and creating an S3 object. The environment variables are set via Figaro.&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;s3 = Aws::S3::Client.new(access_key_id: ENV[&amp;#39;AMAZON_S3_KEY_ID&amp;#39;], secret_access_key: ENV[&amp;#39;AMAZON_S3_SECRET&amp;#39;])
s3.list_buckets
=&amp;gt; #&amp;lt;struct Aws::S3::Types::ListBucketsOutput
 buckets=
  [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Create a bucket&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;resp = s3.create_bucket({ bucket: &amp;quot;analytics-office-data&amp;quot; })
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Upload a file&lt;/h3&gt;

&lt;p&gt;On S3 there&amp;#39;s a limitation on the number of buckets you can use, and there&amp;#39;s no such thing as a concept of a folder.
However, you can mimic folders using the &lt;code&gt;prefix&lt;/code&gt; feature.&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;file_name = &amp;#39;SDI_Download_Data-20140930.csv&amp;#39; 
prefix=&amp;#39;downloaded_files&amp;#39;

file_path=File.join(SOURCE_DIR, file_name)
contents = File.open(file_path,&amp;#39;r&amp;#39;) { |f| f.read }
s3.put_object(bucket: &amp;#39;analytics-office-data&amp;#39;, key: &amp;quot;#{prefix}/#{file_name}&amp;quot;, body: contents)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or more conscise:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;File.open(file_path, &amp;#39;rb&amp;#39;) do |file|
  s3.put_object(bucket: &amp;#39;analytics-office-data&amp;#39;, key: &amp;quot;#{prefix}/#{file_name}&amp;quot;, body: file)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://aws.amazon.com/blogs/developer/uploading-files-to-amazon-s3/"&gt;Another good resource&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Read back that file&lt;/h3&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;prefix=&amp;#39;downloaded_files&amp;#39;
s3.list_objects({ bucket: &amp;#39;analytics-office-data&amp;#39;, prefix: prefix })
=&amp;gt; #&amp;lt;struct Aws::S3::Types::ListObjectsOutput
 is_truncated=false,
 marker=&amp;quot;&amp;quot;,
 next_marker=nil,
 contents=
  [#&amp;lt;struct Aws::S3::Types::Object
    key=&amp;quot;SDI_Download_Data-20140930.csv&amp;quot;,
    last_modified=2017-01-12 18:19:34 UTC,
    etag=&amp;quot;\&amp;quot;411adb204166d574987bacde05b1d1dd\&amp;quot;&amp;quot;,
    size=2404972,
    storage_class=&amp;quot;STANDARD&amp;quot;,
  ],
 name=&amp;quot;analytics-office-data&amp;quot;,
 prefix=&amp;quot;&amp;quot;,
 delimiter=nil,
 max_keys=1000,
 common_prefixes=[],
 encoding_type=&amp;quot;url&amp;quot;&amp;gt;

 r = s3.get_object({ bucket: &amp;#39;analytics-office-data&amp;#39;, key: &amp;quot;#{prefix}/SDI_Download_Data-20140930.csv&amp;quot; })
 =&amp;gt; #&amp;lt;struct Aws::S3::Types::GetObjectOutput
  body=#&amp;lt;StringIO:0x007f808669ed40&amp;gt;,
  delete_marker=nil,
  accept_ranges=&amp;quot;bytes&amp;quot;,
  expiration=nil,
  restore=nil,
  last_modified=2017-01-12 19:13:50 +0000,
  content_length=2404972,
  etag=&amp;quot;\&amp;quot;411adb204166d574987bacde05b1d1dd\&amp;quot;&amp;quot;,
  missing_meta=nil,
  version_id=nil,
  cache_control=nil,
  content_disposition=nil,
  content_encoding=nil,
  content_language=nil,
  content_range=nil,
  content_type=&amp;quot;&amp;quot;,
  expires=nil,
  expires_string=nil,
  website_redirect_location=nil,
  server_side_encryption=nil,
  metadata={},
  sse_customer_algorithm=nil,
  sse_customer_key_md5=nil,
  ssekms_key_id=nil,
  storage_class=nil,
  request_charged=nil,
  replication_status=nil&amp;gt;

file_contents = r.body.read  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An alternative way of reading is:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;file_contents = AWS::S3.new.buckets[&amp;#39;analytics-office-data&amp;#39;].objects[&amp;#39;#{prefix}/SDI_Download_Data-20140930.csv&amp;#39;].read
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>
  <entry>
    <title>Ruby - Don't Freeze User-Defined Strings!</title>
    <link rel="alternate" href="http://blog.url.com/2017/01/07/ruby-string-freeze-memory.html"/>
    <id>http://blog.url.com/2017/01/07/ruby-string-freeze-memory.html</id>
    <published>2017-01-07T01:30:00-05:00</published>
    <updated>2017-01-14T23:46:42-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;This week I was working on a Rails project that involved keeping a large hash of dynamic data in memory. On first 
thought, I was going to build the hash keys based on several data points which will be combined into a hash key. It
would have looked something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;element_name = &amp;#39;NETINC&amp;#39;
period = &amp;#39;20160930&amp;#39;
span = &amp;#39;span_trailing_twelve_months&amp;#39;

&amp;quot;#{element_name}_#{period}_#{span}&amp;quot;
#=&amp;gt; &amp;quot;NETINC_20160930_span_trailing_twelve_months&amp;quot;


# ---------------------------------
# Then I would be able to reference
# the hash like this:

hash[&amp;#39;NETINC_20160930_span_trailing_twelve_months&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if once I build the hash keys I freeze them using &lt;code&gt;String.freeze&lt;/code&gt;, do they get garbage collected when I&amp;#39;m no 
longer processing that key? So let&amp;#39;s say I&amp;#39;m making thousands of these hash keys, process the hash and then move on
to a new data set. Would Ruby keep the defunct hash key strings in memory for the remainder of the program?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The answer is YES!&lt;/strong&gt; Freezing the keys could possibly cause a memory leak because the program will be maintaining
each string object in an in-memory table even after I&amp;#39;m done using it. The memory pile of string objects could
grow indefinitely. This is why freezing strings of user-defined input could be very dangerous - a malicious user
could crash your server by causing it to run out of memory this way.&lt;/p&gt;

&lt;p&gt;I verified this in a discussion with the Chicago Ruby Slack group:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;foo&amp;quot;.freeze.object_id == &amp;quot;foo&amp;quot;.freeze.object_id&amp;quot; # =&amp;gt; true&lt;/code&gt;, but without the freeze it&amp;#39;s &lt;code&gt;false&lt;/code&gt;. And if 
&lt;code&gt;def a; &amp;quot;foo&amp;quot;.freeze.object_id; end; a; a&lt;/code&gt; gives the same id twice.&lt;/p&gt;

&lt;p&gt;Oh yeah, good point... it does allow some memory optimizations if you freeze it, like two strings being the same 
string in memory if they&amp;#39;re frozen and identical&lt;/p&gt;

&lt;p&gt;Wrapped up work and dug a minute: in &lt;code&gt;string.c&lt;/code&gt;, the retaining is happening in &lt;code&gt;str_new_frozen&lt;/code&gt;. The vm calls 
&lt;code&gt;str_replace_shared_without_enc&lt;/code&gt; to eval the string literal, that calls &lt;code&gt;rb_fstring&lt;/code&gt;, that calls 
&lt;code&gt;str_replace_shared_without_enc&lt;/code&gt;, that calls &lt;code&gt;str_new_frozen&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;They&amp;#39;re marked as SHARED. Then &lt;code&gt;gc.c&lt;/code&gt;, &lt;code&gt;gc_mark_children&lt;/code&gt; does &lt;code&gt;gc_mark(objspace, any-&amp;gt;as.string.as.heap.aux.shared);&lt;/code&gt;
on all the shared strings so unless there&amp;#39;s something I&amp;#39;m not spotting that sneaks around to unset SHARED those 
strings are retained for the life of the process.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The approach I took to get around this problem was to build my hash to be dimensions deep. So to access the value,
I would instead use a chain of keys:&lt;/p&gt;

&lt;pre&gt;&lt;code class="ruby"&gt;hash[&amp;#39;NETINC&amp;#39;][&amp;#39;20160930&amp;#39;][&amp;#39;span_trailing_twelve_months&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All it took was a small modification of the fetch methods wrapping my Hash to implement this. &lt;code&gt;element_name&lt;/code&gt; and &lt;code&gt;span&lt;/code&gt; 
are fine to freeze because there is a finite number of them in my program.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Git Submodule vs. Subtree</title>
    <link rel="alternate" href="http://blog.url.com/2016/09/26/git-submodule-vs-subtree.html"/>
    <id>http://blog.url.com/2016/09/26/git-submodule-vs-subtree.html</id>
    <published>2016-09-26T11:30:00-04:00</published>
    <updated>2017-01-14T23:46:42-05:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;strong&gt;&amp;quot;Shared Repo&amp;quot;&lt;/strong&gt; refers to the code which is shared and will be packaged in a submodule or subtree.
&lt;strong&gt;&amp;quot;Parent Project Repo&amp;quot;&lt;/strong&gt; refers to the project that is going to be including the &lt;em&gt;Shared Repo&lt;/em&gt; as
a submodule or subtree. &lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;h3&gt;Submodule&lt;/h3&gt;

&lt;p&gt;Submodules behave like a separate repo within your parent repo. When you are in the submodule directory,
you can use Git commands as if you were working on the submodule repo directly. The parent repo only 
tracks the version of the submodule currently loaded by its commit hash. The parent repo therefore
only stays in sync with the shared repo via this reference. Any changes made within the submodule
directory cannot be committed by the parent repo. You have to go into the submodule directory and 
commit/push them from the shared repo.&lt;/p&gt;

&lt;h3&gt;Subtree&lt;/h3&gt;

&lt;p&gt;Subtree is just a set of macros that simplify Git tricks for merging a secondary shared code repo
into your parent project.&lt;/p&gt;

&lt;h2&gt;Initialization&lt;/h2&gt;

&lt;h3&gt;Submodule&lt;/h3&gt;

&lt;p&gt;To start the submodule, it&amp;#39;s kind of like cloning another git repo: 
&lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;destination-dir&amp;gt;&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;Example:
```
 (master)$ git submodule add git@github.com:wakproductions/gitsub-submodule.git lib/gitsub-submodule
Cloning into &amp;#39;/Users/wkotzan/Development/gitsub-base/lib/gitsub-submodule&amp;#39;...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Receiving objects: 100% (3/3), done.&lt;/p&gt;

&lt;p&gt;(master)$ git status
On branch master
Changes to be committed:
  (use &amp;quot;git reset HEAD &lt;file&gt;...&amp;quot; to unstage)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new file:   .gitmodules
new file:   lib/gitsub-submodule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(master)$ cat .gitmodules
[submodule &amp;quot;lib/gitsub-submodule&amp;quot;]
    path = lib/gitsub-submodule
    url = git@github.com:wakproductions/gitsub-submodule.git&lt;/p&gt;

&lt;p&gt;(master)$ git diff&lt;/p&gt;

&lt;p&gt;(master)$ git diff --cached
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..dfc8421
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule &amp;quot;lib/gitsub-submodule&amp;quot;]
+       path = lib/gitsub-submodule
+       url = git@github.com:wakproductions/gitsub-submodule.git
diff --git a/lib/gitsub-submodule b/lib/gitsub-submodule
new file mode 160000
index 0000000..9dd60f8
--- /dev/null
+++ b/lib/gitsub-submodule
@@ -0,0 +1 @@
+Subproject commit 9dd60f8fc47f089dd5081a0ed73efb7cc923fd9c
```&lt;/p&gt;

&lt;h3&gt;Subtree&lt;/h3&gt;

&lt;p&gt;Use &lt;code&gt;git subtree add --prefix &amp;lt;dest-dir&amp;gt; &amp;lt;remote-name&amp;gt; &amp;lt;remote-branch&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git remote add subtree-origin git@github.com:wakproductions/gitsub-subtree.git
 (master)$ git subtree add --prefix lib/github-subtree subtree-origin master
git fetch subtree-origin master
warning: no common commits
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wakproductions/gitsub-subtree
 * branch            master     -&amp;gt; FETCH_HEAD
 * [new branch]      master     -&amp;gt; subtree-origin/master
Added dir &amp;#39;lib/github-subtree&amp;#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;How to Pull Changes from Shared Repo into Parent Project Repo&lt;/h2&gt;

&lt;h3&gt;Submodule&lt;/h3&gt;

&lt;p&gt;You can work in the submodule as if it were its own Git Repo. First you have to go into the submodule
directory:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cd lib/gitsub-submodule &amp;amp;&amp;amp; git fetch &amp;amp;&amp;amp; git merge origin/master&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git fetch
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wakproductions/gitsub-submodule
   9dd60f8..e3bedf9  master     -&amp;gt; origin/master
 (master)$ git merge origin/master
Updating 9dd60f8..e3bedf9
Fast-forward
 submodule-library.rb | 4 ++++
 1 file changed, 4 insertions(+)
 (master)$ git log
commit e3bedf9137028aa63dd88ff1e708ce08e921cc99
Author: Winston Kotzan &amp;lt;wak@wakproductions.com&amp;gt;
Date:   Mon Sep 26 15:40:17 2016 -0400

    Add change to shared repo

commit 9dd60f8fc47f089dd5081a0ed73efb7cc923fd9c
Author: Winston Kotzan &amp;lt;wak@wakproductions.com&amp;gt;
Date:   Wed Sep 21 10:25:56 2016 -0400

    First commit - submodule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You also need to update the parent repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git status
On branch master
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)

    modified:   lib/gitsub-submodule (new commits, modified content)

 (master)$ git diff
diff --git a/lib/gitsub-submodule b/lib/gitsub-submodule
index 9dd60f8..e3bedf9 160000
--- a/lib/gitsub-submodule
+++ b/lib/gitsub-submodule
@@ -1 +1 @@
-Subproject commit 9dd60f8fc47f089dd5081a0ed73efb7cc923fd9c
+Subproject commit e3bedf9137028aa63dd88ff1e708ce08e921cc99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** Note that the commit reference in the submodule has changed and needs to be committed in the parent repo**&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ gc &amp;quot;Update submodule&amp;quot;
On branch master
[master 673e460] Update submodule
 1 file changed, 1 insertion(+), 1 deletion(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A disadvantage of using submodules is that your commit history will get dirty with &amp;quot;Update submodule&amp;quot; style commits
in the parent project repo. See caveats section below for more details.&lt;/p&gt;

&lt;h3&gt;Subtree&lt;/h3&gt;

&lt;p&gt;It works very similar to a Git fetch/merge or pull.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git subtree pull --prefix lib/github-subtree subtree-origin master
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From github.com:wakproductions/gitsub-subtree
 * branch            master     -&amp;gt; FETCH_HEAD
   5f12af3..b7631b5  master     -&amp;gt; subtree-origin/master
Merge made by the &amp;#39;recursive&amp;#39; strategy.
 lib/github-subtree/subtree-library.rb | 4 ++++
 1 file changed, 4 insertions(+)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;How to Push Changes from Parent Project Repo to Shared Repo&lt;/h2&gt;

&lt;h3&gt;Submodule&lt;/h3&gt;

&lt;p&gt;What happens if you modify the code in the submodule from the parent project? It labels that commit
pointer as &amp;quot;dirty&amp;quot;, and you can&amp;#39;t commit the change from the parent repo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git status
On branch master
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)

    modified:   lib/gitsub-submodule (modified content)

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
 (master)$ git diff
diff --git a/lib/gitsub-submodule b/lib/gitsub-submodule
--- a/lib/gitsub-submodule
+++ b/lib/gitsub-submodule
@@ -1 +1 @@
-Subproject commit e3bedf9137028aa63dd88ff1e708ce08e921cc99
+Subproject commit e3bedf9137028aa63dd88ff1e708ce08e921cc99-dirty
 (master)$ git add .
 (master)$ git status
On branch master
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
  (commit or discard the untracked or modified content in submodules)

    modified:   lib/gitsub-submodule (modified content)

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have to go into the submodule directory and work with it there. In this case, I&amp;#39;m going to make a new
branch/pull request for the submodule.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ cd lib/gitsub-submodule
 (master)$ pwd
/Users/wkotzan/Development/gitsub-base/lib/gitsub-submodule
 (master)$ git status
On branch master
Your branch is up-to-date with &amp;#39;origin/master&amp;#39;.
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

    modified:   submodule-library.rb

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
 (master)$ git diff
diff --git a/submodule-library.rb b/submodule-library.rb
index 07692ef..fc6589a 100644
--- a/submodule-library.rb
+++ b/submodule-library.rb
@@ -5,7 +5,11 @@ class MySubmoduleLibrary
   end

   def code_change_in_shared_repo
-    puts &amp;quot;This code was added from the shared repo&amp;quot;
+    puts &amp;quot;This code was modified from the parent repo&amp;quot;
+  end
+
+  def code_change_from_parent_repo
+    puts &amp;quot;This code was added from the parent repo&amp;quot;
   end

 end
\ No newline at end of file
 (master)$ git stash
Saved working directory and index state WIP on master: e3bedf9 Add change to shared repo
HEAD is now at e3bedf9 Add change to shared repo
 (master)$ git status
On branch master
Your branch is up-to-date with &amp;#39;origin/master&amp;#39;.
nothing to commit, working tree clean
 (master)$ git checkout -b changes_from_parent_repo
Switched to a new branch &amp;#39;changes_from_parent_repo&amp;#39;
 (changes_from_parent_repo)$ git stash pop
On branch changes_from_parent_repo
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

    modified:   submodule-library.rb

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
Dropped refs/stash@{0} (b0c7a7936dda06e25049f121207eff7599d084f7)
 (changes_from_parent_repo)$ git add .
 (changes_from_parent_repo)$ git commit -m &amp;quot;New method and modifications from parent repo&amp;quot;
[changes_from_parent_repo 60c13b2] New method and modifications from parent repo
 1 file changed, 5 insertions(+), 1 deletion(-)
 (changes_from_parent_repo)$ git push origin changes_from_parent_repo
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 379 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local objects.
To github.com:wakproductions/gitsub-submodule.git
 * [new branch]      changes_from_parent_repo -&amp;gt; changes_from_parent_repo
 (changes_from_parent_repo)$ git checkout master
Switched to branch &amp;#39;master&amp;#39;
Your branch is up-to-date with &amp;#39;origin/master&amp;#39;.

****** CHANGES IN BRANCH changes_from_parent_repo MERGED VIA PULL REQUEST ****** 

 (master)$ git pull
remote: Counting objects: 1, done.
remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (1/1), done.
From github.com:wakproductions/gitsub-submodule
   e3bedf9..f34c1aa  master     -&amp;gt; origin/master
Updating e3bedf9..f34c1aa
Fast-forward
 submodule-library.rb | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Subtree&lt;/h3&gt;

&lt;p&gt;By opening a new branch, when you push it up you can merge it into the shared repo just like any other
pull request.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; (master)$ git checkout -b backported_changes_to_subtree
Switched to a new branch &amp;#39;backported_changes_to_subtree&amp;#39;
 (backported_changes_to_subtree)$ git status
On branch backported_changes_to_subtree
Changes not staged for commit:
  (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
  (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)

    modified:   lib/github-subtree/subtree-library.rb

no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
 (backported_changes_to_subtree)$ git diff
diff --git a/lib/github-subtree/subtree-library.rb b/lib/github-subtree/subtree-library.rb
index efb4e2b..e5a2916 100644
--- a/lib/github-subtree/subtree-library.rb
+++ b/lib/github-subtree/subtree-library.rb
@@ -4,8 +4,8 @@ class MySubTree
     puts &amp;quot;hello from subtree&amp;quot;
   end

-  def update_from_subtree_project
-    puts &amp;quot;this is an update from the subtree project&amp;quot;
+  def update_from_parent_project
+    puts &amp;quot;this is an update from the parent project&amp;quot;
   end

 end
\ No newline at end of file
 (backported_changes_to_subtree)$ git add .
 (backported_changes_to_subtree)$ git commit -m &amp;quot;Implement modification to subtree&amp;quot;
[backported_changes_to_subtree 672332e] Implement modification to subtree
 1 file changed, 2 insertions(+), 2 deletions(-)
 (backported_changes_to_subtree)$ git subtree push --prefix lib/github-subtree subtree-origin backported_changes_to_subtree
git push using:  subtree-origin backported_changes_to_subtree
Counting objects: 3, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 336 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
remote: Resolving deltas: 100% (1/1), completed with 1 local objects.
To github.com:wakproductions/gitsub-subtree.git
 * [new branch]      8f79e421908a5d2ab2e6554c6b4535e5b5a83bac -&amp;gt; backported_changes_to_subtree
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Submodule Caveats&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When you clone such a project with submodules, by default you get the directories 
that contain submodules, but none of the files within them yet. (https://git-scm.com/book/en/v2/Git-Tools-Submodules)
To get around this, either do &lt;code&gt;git clone --recursive&lt;/code&gt; or do &lt;code&gt;git submodule init &amp;amp;&amp;amp; git submodule update&lt;/code&gt; after the 
clone.&lt;/li&gt;
&lt;li&gt;A disadvantage of using submodules is that your commit history will get dirty with &amp;quot;Update submodule&amp;quot; style commits
in the parent project repo. You won&amp;#39;t have specific information on the version bumps happening within the submodule.
One of the things that I like about packaging via Ruby gem vs using a library as a submodule is that you can manage
meaningful version numbers in a Ruby gem whereas all you have to go by in a submodule is a commit hash. This could
make it difficult to track the changes to the shared repo that breaks other systems dependent on it. Let&amp;#39;s say you make
a change to a shared repo, then updated other projects using that shared repo. Things break in those other projects.
How do you roll back? How do you identify which version of the shared repo each of your projects is running on?&lt;/li&gt;
&lt;li&gt;When using CI, some additional configuration may be needed: https://circleci.com/docs/external-resources/
https://circleci.com/docs/configuration/#checkout&lt;/li&gt;
&lt;li&gt;In comparison to subtree, there&amp;#39;s an extra step in that you have to commit your updates to the submodule
and then go into the parent repository and make another commit to update the submodule reference. So
every update to the submodule consists of a two-step process.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Subtree Caveats&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Because subtree is based on a combination of other Git routines, the command sequences are less
straightforward.&lt;/li&gt;
&lt;li&gt;I recommend immediately pushing up any changes in the subtree because if you make a lot of changes
to the parent repo and forget about updating the shared repo origin of the subtree, then you&amp;#39;ll eventually
end up with a very large pull request with a lot of divergence in the shared repo. &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Subtree Advantages&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The subtree code is considered a part of the parent repository, so you don&amp;#39;t require special configuration
the way you do with a submodule.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt"&gt;Official Subtree Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@porteneuve/mastering-git-subtrees-943d29a798ec#.zias44kio"&gt;Mastering Git Subtrees (excellent resource)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blogs.atlassian.com/2013/05/alternatives-to-git-submodule-git-subtree/"&gt;Atlassian Subtree Guide&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
